<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <script src="https://threejs.org/build/three.min.js"></script>
    <script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
    <script src="https://threejs.org/examples/js/controls/TransformControls.js"></script>
    <script src="https://threejs.org/examples/js/loaders/OBJLoader.js"></script>
    <script src="https://threejs.org/examples/js/loaders/MTLLoader.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.6/dat.gui.min.js"></script>
    <style>
      body {
        background-color: #bfe3dd;
        color: #000;
      }
    </style>
  </head>
  <body>
    <h1 align="center">CAP4720 Final Project: Interior Design Simulator</h1>
    <script type="text/javascript">
      'use strict';

      let scene, object, camera, renderer, cameraControls, activeObject;
      let furnitureNames = ['chair', 'couch'];
      let furnitureObjects = [];
      let furnitureMap = new Map();
      var raycaster = new THREE.Raycaster();
      var mouse = new THREE.Vector2();

      let WIDTH = window.innerWidth;
      let HEIGHT = window.innerHeight;

      function init() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x80aba4);
        initRenderer();
        initScene();
        initMeshes();
        createGUI();
        handleWindowResize();
        document.addEventListener('mousemove', onMouseMove, false);
        window.requestAnimationFrame(render);
      }

      function initRenderer() {
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.gammaOutput = true;
        renderer.gammaFactor = 2.2;
        renderer.setSize(WIDTH, HEIGHT);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setClearColor(0x888888, 1);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);
      }
      function initScene() {
        initCamera();

        // Ground
        // var mesh = new THREE.Mesh(
        //   new THREE.PlaneBufferGeometry(2000, 2000),
        //   new THREE.MeshPhongMaterial({ color: 0xbfe3dd, depthWrite: false })
        // );
        // mesh.rotation.x = -Math.PI / 2;
        // scene.add(mesh);
        // var grid = new THREE.GridHelper(200, 40, 0x000000, 0x000000);
        // grid.material.opacity = 0.2;
        // grid.material.transparent = true;
        // scene.add(grid);

        // Environment
        let envOLoader = new THREE.OBJLoader();
        let envMLoader = new THREE.MTLLoader();
        envMLoader.setPath('./assets/');
        envMLoader.load('environment.mtl', function(mtls) {
          mtls.preload();
          envOLoader.setMaterials(mtls);
          envOLoader.setPath('./assets/');
          envOLoader.load(
            'environment.obj',
            function(obj) {
              obj.receiveShadow = true;
              obj.position.set(0, 0, 0);
              obj.traverse(function(child) {
                if (child instanceof THREE.Mesh) {
                  child.receiveShadow = true;
                  child.material.shininess = 0;
                }
              });
              scene.add(obj);
              render();
            },
            function(xhr) {
              if (xhr.lengthComputable) {
                let percentComplete = (xhr.loaded / xhr.total) * 100;
                console.log(
                  'model' + Math.round(percentComplete, 2) + '% downloaded'
                );
              }
            },
            function() {}
          );
        });

        // Room
        let roomOLoader = new THREE.OBJLoader();
        let roomMLoader = new THREE.MTLLoader();
        roomMLoader.setPath('./assets/');
        roomMLoader.load('room.mtl', function(mtls) {
          mtls.preload();
          roomOLoader.setMaterials(mtls);
          roomOLoader.setPath('./assets/');
          roomOLoader.load(
            'room.obj',
            function(obj) {
              obj.receiveShadow = true;
              obj.position.set(0, 0, 0);
              obj.traverse(function(child) {
                if (child instanceof THREE.Mesh) {
                  child.receiveShadow = true;
                  child.material.shininess = 0;
                }
              });
              scene.add(obj);
              render();
            },
            function(xhr) {
              if (xhr.lengthComputable) {
                let percentComplete = (xhr.loaded / xhr.total) * 100;
                console.log(
                  'model' + Math.round(percentComplete, 2) + '% downloaded'
                );
              }
            },
            function() {}
          );
        });

        initLight();
      }

      function initCamera() {
        camera = new THREE.PerspectiveCamera(50, WIDTH / HEIGHT, 0.01, 1000);
        camera.position.set(-36, 33, -50);
        camera.lookAt(scene.position);
        cameraControls = new THREE.OrbitControls(camera, renderer.domElement);
        cameraControls.addEventListener('change', function() {
          camera.updateProjectionMatrix();
          render();
        });
      }

      function initLight() {
        var light = new THREE.HemisphereLight(0xffffff, 0x444444);
        light.position.set(0, 20, 0);
        scene.add(light);
        var light = new THREE.HemisphereLight(0xffffff, 0x444444);
        light.position.set(0, 10, 0);
        scene.add(light);
        var fillLight = new THREE.DirectionalLight(0xffffff, 1);
        fillLight.position.set(1, 0, 1);
        scene.add(fillLight);
      }

      function initMeshes() {
        furnitureNames.forEach(piece => {
          console.log('about to load: ', piece);
          loadObject(piece);
        });
      }

      function createGUI() {
        var guiObject = {
          geomType: 'none'
        };
        let guiController = new dat.GUI();
        let furnitureFolder = guiController.addFolder('Furniture');
        furnitureFolder
          .add(guiObject, 'geomType', [
            'none',
            'chair',
            'couch',
            'coffee table'
          ])
          .name('Piece')
          .onChange(function(val) {
            console.log('selected furniture piece: ' + val);
            if (val != 'none') {
              scene.add(furnitureMap.get(val));
              render();
              handleWindowResize();
            }
          });
      }

      function loadObject(name) {
        let objLoader = new THREE.OBJLoader();
        let mtlLoader = new THREE.MTLLoader();

        mtlLoader.setPath('./assets/');
        mtlLoader.load(name + '.mtl', function(mtls) {
          mtls.preload();
          objLoader.setMaterials(mtls);
          objLoader.setPath('./assets/');
          objLoader.load(
            name + '.obj',
            function(obj) {
              obj.traverse(function(child) {
                if (child instanceof THREE.Mesh) {
                  child.castShadow = true;
                  child.material.shininess = 0;
                }
              });
              obj.position.set(0, 0, 0);
              furnitureMap.set(name, obj);
              furnitureObjects.push(obj);
            },
            function(xhr) {
              if (xhr.lengthComputable) {
                let percentComplete = (xhr.loaded / xhr.total) * 100;
                console.log(
                  name + ' ' + Math.round(percentComplete, 2) + '% downloaded'
                );
              }
            },
            function() {}
          );
        });
      }

      function handleWindowResize() {
        window.addEventListener('resize', function() {
          WIDTH = window.innerWidth;
          HEIGHT = window.innerHeight;
          renderer.setSize(WIDTH, HEIGHT);
          camera.aspect = WIDTH / HEIGHT;
          camera.updateProjectionMatrix();
          render();
        });
      }

      function onMouseMove(event) {
        // calculate mouse position in normalized device coordinates
        // (-1 to +1) for both components
        event.preventDefault();
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
      }

      function render() {
        // update the picking ray with the camera and mouse position
        raycaster.setFromCamera(mouse, camera);

        // calculate objects intersecting the picking ray
        var intersects = raycaster.intersectObjects(furnitureObjects);

        for (var i = 0; i < intersects.length; i++) {
          intersects[i].object.material.color.set(0xffffff);
          console.log(intersects[i]);
        }
        renderer.render(scene, camera);
      }

      init();
      render();
    </script>
  </body>
</html>
