<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <script src="https://threejs.org/build/three.min.js"></script>
    <script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
    <script src="https://threejs.org/examples/js/controls/DragControls.js"></script>
    <script src="https://threejs.org/examples/js/loaders/OBJLoader.js"></script>
    <script src="https://threejs.org/examples/js/loaders/MTLLoader.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.6/dat.gui.min.js"></script>
    <link rel="stylesheet" href="styles.css" />
  </head>
  <body>
    <h1 align="center">CAP4720 Final Project: Interior Design Simulator</h1>
    <div class="menu">
      <div class="menu-main">
        <div class="menu-main-furniture-selection">
          <img
            src="assets/thumbnails/chair_thumbnail.png"
            alt="Chair"
            height="60"
            width="60"
            onclick="addPiece('chair')"
          />
        </div>
      </div>
    </div>
    <script type="text/javascript">
      'use strict';

      let scene, object, camera, renderer, cameraControls, activeObject;
      let furnitureNames = ['chair', 'couch'];
      let furnitureObjects = [];
      let furnitureMap = new Map();

      let WIDTH = window.innerWidth;
      let HEIGHT = window.innerHeight;

      function init() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x80aba4);
        initRenderer();
        initScene();
        initMeshes();
        handleWindowResize();
        window.requestAnimationFrame(render);

        var controls = new THREE.DragControls(
          furnitureObjects,
          camera,
          renderer.domElement
        );
        controls.addEventListener('dragstart', function(event) {
          console.log('drag start on object: ', event.object);
          event.object.material.emissive.set(0xaaaaaa);
          activeObject = event.object;
          cameraControls.enabled = false;
        });
        controls.addEventListener('dragend', function(event) {
          event.object.material.emissive.set(0x000000);
          event.object.position.x = round_to_precision(event.object.position.x, 5);
          event.object.position.z = round_to_precision(event.object.position.z, 5);
          event.object.position.y = 0;
          cameraControls.enabled = true;
        });
      }

      function initRenderer() {
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.gammaOutput = true;
        renderer.gammaFactor = 2.2;
        renderer.setSize(WIDTH, HEIGHT);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setClearColor(0x888888, 1);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);
      }
      function initScene() {
        initCamera();

        // mesh.rotation.x = -Math.PI / 2;
        // scene.add(mesh);
        // var grid = new THREE.GridHelper(200, 40, 0x000000, 0x000000);
        // grid.material.opacity = 0.2;
        // grid.material.transparent = true;
        // scene.add(grid);

        // Environment
        let envOLoader = new THREE.OBJLoader();
        let envMLoader = new THREE.MTLLoader();
        envMLoader.setPath('./assets/');
        envMLoader.load('environment.mtl', function(mtls) {
          mtls.preload();
          envOLoader.setMaterials(mtls);
          envOLoader.setPath('./assets/');
          envOLoader.load(
            'environment.obj',
            function(obj) {
              obj.receiveShadow = true;
              obj.position.set(0, 0, 0);
              obj.traverse(function(child) {
                if (child instanceof THREE.Mesh) {
                  child.receiveShadow = true;
                  child.material.shininess = 0;
                }
              });
              scene.add(obj);
              render();
            },
            function(xhr) {
              if (xhr.lengthComputable) {
                let percentComplete = (xhr.loaded / xhr.total) * 100;
                console.log(
                  'model' + Math.round(percentComplete, 2) + '% downloaded'
                );
              }
            },
            function() {}
          );
        });

        // Room
        let roomOLoader = new THREE.OBJLoader();
        let roomMLoader = new THREE.MTLLoader();
        roomMLoader.setPath('./assets/');
        roomMLoader.load('room.mtl', function(mtls) {
          mtls.preload();
          roomOLoader.setMaterials(mtls);
          roomOLoader.setPath('./assets/');
          roomOLoader.load(
            'room.obj',
            function(obj) {
              obj.receiveShadow = true;
              obj.position.set(0, 0, 0);
              obj.traverse(function(child) {
                if (child instanceof THREE.Mesh) {
                  child.receiveShadow = true;
                  child.material.shininess = 0;
                }
              });
              scene.add(obj);
              render();
            },
            function(xhr) {
              if (xhr.lengthComputable) {
                let percentComplete = (xhr.loaded / xhr.total) * 100;
                console.log(
                  'model' + Math.round(percentComplete, 2) + '% downloaded'
                );
              }
            },
            function() {}
          );
        });

        initLight();
      }

      function initCamera() {
        camera = new THREE.PerspectiveCamera(50, WIDTH / HEIGHT, 0.01, 1000);
        camera.position.set(-36, 33, -50);
        camera.lookAt(scene.position);
        cameraControls = new THREE.OrbitControls(camera, renderer.domElement);
        cameraControls.addEventListener('change', function() {
          camera.updateProjectionMatrix();
          render();
        });
      }

      function initLight() {
        var light = new THREE.HemisphereLight(0xffffff, 0x444444);
        light.position.set(0, 20, 0);
        scene.add(light);
        var light = new THREE.HemisphereLight(0xffffff, 0x444444);
        light.position.set(0, 10, 0);
        scene.add(light);
        var fillLight = new THREE.DirectionalLight(0xffffff, 1);
        fillLight.position.set(1, 0, 1);
        scene.add(fillLight);
      }

      function initMeshes() {
        furnitureNames.forEach(piece => {
          console.log('about to load: ', piece);
          loadObject(piece);
        });
      }

      // When thumbnail is clicked, corresponding object is add to the scene.
      // Object is then deleted from the furniture map and reloaded to allow
      // for duplicates.
      function addPiece(name) {
        scene.add(furnitureMap.get(name));
        render();
        furnitureMap.delete(name);
        loadObject(name);
        handleWindowResize();
      }

      function loadObject(name) {
        let objLoader = new THREE.OBJLoader();
        let mtlLoader = new THREE.MTLLoader();

        mtlLoader.setPath('./assets/');
        mtlLoader.load(name + '.mtl', function(mtls) {
          mtls.preload();
          objLoader.setMaterials(mtls);
          objLoader.setPath('./assets/');
          objLoader.load(
            name + '.obj',
            function(obj) {
              obj.traverse(function(child) {
                if (child instanceof THREE.Mesh) {
                  child.castShadow = true;
                  child.material.shininess = 0;
                }
              });
              obj.position.set(0, 0, 0);
              furnitureMap.set(name, obj);
              furnitureObjects.push(obj);
            },
            function(xhr) {
              if (xhr.lengthComputable) {
                let percentComplete = (xhr.loaded / xhr.total) * 100;
                console.log(
                  name + ' ' + Math.round(percentComplete, 2) + '% downloaded'
                );
              }
            },
            function() {}
          );
        });
      }

      function handleWindowResize() {
        window.addEventListener('resize', function() {
          WIDTH = window.innerWidth;
          HEIGHT = window.innerHeight;
          renderer.setSize(WIDTH, HEIGHT);
          camera.aspect = WIDTH / HEIGHT;
          camera.updateProjectionMatrix();
          render();
        });
      }

      function animate() {
        requestAnimationFrame(animate);
        render();
      }

      function render() {
        renderer.render(scene, camera);
      }

      function round_to_precision(x, precision) {
        var y = +x + (precision === undefined ? 0.5 : precision/2);
        return y - (y % (precision === undefined ? 1 : +precision));
      }

      init();
      animate();
    </script>
  </body>
</html>
